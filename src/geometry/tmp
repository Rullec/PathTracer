diff --git a/src/geometry/cBxDF.cpp b/src/geometry/cBxDF.cpp
index 47fe751..14eb8ec 100644
--- a/src/geometry/cBxDF.cpp
+++ b/src/geometry/cBxDF.cpp
@@ -149,32 +149,42 @@ std::shared_ptr<cBxDF> BuildBxDF(tMaterial * material)
 */
 tVector cBSDF::evaluate(const tVector & wi, const tVector & wo, const tVector & normal)
 {
-
     assert(cMathUtil::IsVector(wi) && cMathUtil::IsNormalized(wi));
     assert(cMathUtil::IsVector(wo) && cMathUtil::IsNormalized(wo));
     assert(cMathUtil::IsVector(normal) && cMathUtil::IsNormalized(normal));
 
     tVector value = tVector::Zero();
     tVector ideal_wo = tVector::Zero();
-    if(wi.dot(normal) > 0 == wo.dot(normal) > 0)
+    if(cGeoUtil::Refract(normal, wi, 1.0 / mNi).hasNaN() == true)
     {
-        // 折射情况
-        ideal_wo = cGeoUtil::Refract(normal, wi, 1.0 / mNi);
-        if(ideal_wo.hasNaN() == true)
-        {
-            std::cout <<"[error] bsdf evalue illegal: can not refract to this direction\n";
-        }
+        // 不能是折射，只能是全反射
+        ideal_wo = cGeoUtil::Reflect(normal, wi);
     }
     else
     {
-        // 全反射情况
-        ideal_wo = cGeoUtil::Reflect(normal, wi);
+        ideal_wo = cGeoUtil::Refract(normal, wi, 1.0 / mNi);
     }
+    // if(wi.dot(normal) > 0 == wo.dot(normal) > 0)
+    // {
+    //     // 折射情况
+    //     ideal_wo = cGeoUtil::Refract(normal, wi, 1.0 / mNi);
+    //     if(ideal_wo.hasNaN() == true)
+    //     {
+    //         return tVector::Ones() * std::nan("");
+    //         std::cout <<"[error] bsdf evalue illegal: can not refract to this direction\n";
+    //     }
+    // }
+    // else
+    // {
+    //     // 全反射情况
+    //     ideal_wo = cGeoUtil::Reflect(normal, wi);
+    // }
 
     double cos_theta = ideal_wo.dot(wo);
     if(cos_theta < 0) cos_theta = 0;
     const int coef = 1;
-    value = tVector::Ones() / (4 * M_PI) * pow(cos_theta, coef);
+    value = tVector::Ones() * cos_theta;
+    // value = tVector::Ones() / (4 * M_PI) * pow(cos_theta, coef);
     // value = tVector::Ones() * (coef + 1) / (4 * M_PI) * pow(cos_theta, coef);
 
     assert(value.hasNaN() == false);
@@ -198,13 +208,12 @@ tVector cBSDF::Sample_f(const tVector & ref_normal, const tVector & wo, tVector
         wi_oppo = cGeoUtil::Reflect(ref_normal, -wo);
     }
 
+    // double pdf;
+    // wi_oppo = cMathUtil::SampleHemiSphereUniform(wi_oppo, pdf);
+
     tVector bsdf_value = tVector::Zero();
     bsdf_value = evaluate(-wi_oppo, wo, ref_normal);
-    
-    if(is_reflect)
-    {
-        // std::cout << bsdf_value.transpose() / (1.0 / (4 * M_PI));
-    }
+
     tVector indirect_coef = bsdf_value / (1.0 / (4 * M_PI)) * std::fabs(wi_oppo.dot(ref_normal));
     assert(indirect_coef.minCoeff() > -1e-6);
     assert(indirect_coef.hasNaN() == false);
diff --git a/src/geometry/cPathTracer.cpp b/src/geometry/cPathTracer.cpp
index 3b0ce54..8616506 100644
--- a/src/geometry/cPathTracer.cpp
+++ b/src/geometry/cPathTracer.cpp
@@ -354,17 +354,21 @@ void cPathTracer::GetDrawResources(std::vector<tLine> & lines, std::vector<tVert
         lines.push_back(income);
         lines.push_back(refract_out);
         lines.push_back(normal_line);
-        // for(int i=0; i<10000; i++)
-        // {
-        //     // tVector in_dir = -cMathUtil::SampleHemiSphereUniform(normal, pdf);
-        //     tVector wo_dir = cMathUtil::SampleSphereUniform(normal, pdf).normalized();
-        //     tVector bxdf_value = bxdf->evaluate(in_dir, wo_dir, normal);
-        //     normal_line.mOri = tVector(0, 0, 0, 1);
-        //     normal_line.mDest = wo_dir;
-        //     normal_line.mColor = tVector::Ones() * bxdf_value.norm() / 2;
-        //     lines.push_back(normal_line);
-        //     // std::cout <<"bxdf_value = " << bxdf_value.transpose() << std::endl;
-        // }
+        for(int i=0; i<10000; i++)
+        {
+            // tVector in_dir = -cMathUtil::SampleHemiSphereUniform(normal, pdf);
+            tVector wo_dir = cMathUtil::SampleSphereUniform(pdf).normalized();
+            tVector bxdf_value = bxdf->evaluate(in_dir, wo_dir, normal);
+            normal_line.mOri = tVector(0, 0, 0, 1);
+            normal_line.mDest = wo_dir;
+            normal_line.mColor = tVector::Ones() * bxdf_value.norm() / 2;
+            if(bxdf_value.hasNaN() == true)
+            {
+                normal_line.mColor = tVector(0.4, 0.5, 0.6, 1);
+            }
+            lines.push_back(normal_line);
+            // std::cout <<"bxdf_value = " << bxdf_value.transpose() << std::endl;
+        }
         
         std::cout <<"白色 入射\n";
         std::cout <<"灰色 法向\n";
